<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>move ¬∑ screen object (keyboard listeners)</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: #1a2a33;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      padding: 1.5rem;
    }

    .game-container {
      background: #273b48;
      border-radius: 3.5rem;
      padding: 2rem 2rem 2.5rem;
      box-shadow: 0 30px 35px -10px #0f1a20;
      width: 800px;
      max-width: 100%;
    }

    h1 {
      color: #f2cfb3;
      font-size: 2.5rem;
      font-weight: 700;
      letter-spacing: -0.02em;
      margin-bottom: 0.2rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .sub {
      color: #9fc1d4;
      margin-bottom: 1.5rem;
      border-bottom: 2px solid #416d84;
      padding-bottom: 0.7rem;
      display: flex;
      justify-content: space-between;
    }

    /* canvas-like area where object moves */
    .move-area {
      background: #1f313d;
      border-radius: 3rem;
      padding: 2rem;
      border: 2px solid #628da5;
      height: 450px;
      position: relative;
      margin-bottom: 1.8rem;
      box-shadow: inset 0 0 15px #0c1a24;
      overflow: hidden;  /* keeps shape inside, but we can also allow boundary stop */
    }

    /* movable shape ‚Äî initially a square, but we add class for circle */
    #movableShape {
      width: 80px;
      height: 80px;
      background: #f5b17b;
      border-radius: 20px;  /* square with slight rounding? but we keep square edges? 20px gives subtle round, but we want both forms. */
      position: absolute;
      left: 40px;
      top: 60px;
      transition: background-color 0.2s, border-radius 0.2s;
      box-shadow: 0 8px 0 #9b5a36, 0 12px 20px #00000060;
      cursor: pointer;
      border: 2px solid #fad5b3;
      z-index: 10;
    }

    /* circle variant via class toggling */
    #movableShape.circle {
      border-radius: 50%;   /* makes it a circle */
      background: #7fc3b0;
      box-shadow: 0 8px 0 #3f7a6b, 0 12px 20px #00000060;
      border-color: #c0efe3;
    }

    .controls-panel {
      background: #1f3643;
      border-radius: 2rem;
      padding: 1.2rem 1.8rem;
      border: 1px solid #6999b3;
      color: white;
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: space-between;
    }

    .key-hint {
      display: flex;
      gap: 1.5rem;
      background: #152d3b;
      padding: 0.6rem 1.5rem;
      border-radius: 60px;
      font-weight: 600;
    }

    .key {
      background: #2e556b;
      padding: 0.4rem 1rem;
      border-radius: 20px;
      border: 1px solid #90b8d1;
    }

    .position-display {
      font-family: monospace;
      background: #14242f;
      padding: 0.6rem 1.8rem;
      border-radius: 60px;
      font-size: 1.2rem;
      border: 1px solid #5282a1;
    }

    button {
      background: #c98f6b;
      border: none;
      color: white;
      font-weight: 700;
      padding: 0.7rem 1.8rem;
      border-radius: 60px;
      font-size: 1.1rem;
      cursor: pointer;
      box-shadow: 0 4px 0 #7b543e;
      transition: 0.08s;
      border: 1px solid #f0b691;
    }

    button:active {
      transform: translateY(3px);
      box-shadow: 0 1px 0 #7b543e;
    }

    .footer {
      margin-top: 1.2rem;
      color: #90adc2;
      text-align: center;
    }
  </style>
</head>
<body>
  <div class="game-container">
    <header>
      <h1>üéÆ spatial ¬∑ move</h1>
      <div class="sub">
        <span>global keyboard listeners (arrow keys / wasd)</span>
        <span>‚¨ú ‚Üî ‚ö™</span>
      </div>
    </header>

    <!-- movement area containing shape -->
    <div class="move-area" id="moveArea">
      <div id="movableShape" class="" style="left: 60px; top: 70px;"></div>
    </div>

    <!-- control panel -->
    <div class="controls-panel">
      <div class="key-hint">
        <span class="key">‚Üê‚Üë‚Üì‚Üí</span>
        <span class="key">W A S D</span>
      </div>
      <div class="position-display" id="posDisplay">x: 60, y: 70</div>
      <button id="toggleShape">üîÅ to circle</button>
    </div>

    <div class="footer">
      üß™ arrow keys OR wasd move ¬∑ shape stays within bounds ¬∑ click toggle to change form
    </div>
  </div>

  <script>
    (function() {
      "use strict";

      // ----- get elements -----
      const shape = document.getElementById('movableShape');
      const posDisplay = document.getElementById('posDisplay');
      const toggleBtn = document.getElementById('toggleShape');
      const moveArea = document.getElementById('moveArea');

      // ----- state (using let for movement) -----
      let posX = 60;        // initial left (px)
      let posY = 70;        // initial top (px)
      let step = 12;        // movement step (pixels per key)

      // shape dimensions (constant)
      const SHAPE_WIDTH = 80;
      const SHAPE_HEIGHT = 80;

      // area boundaries (with padding to keep shape fully inside)
      let areaWidth, areaHeight;

      // ----- helper to update position and enforce boundaries -----
      function updatePosition(deltaX, deltaY) {
        // get fresh container dimensions (in case of resize)
        const containerRect = moveArea.getBoundingClientRect();
        areaWidth = containerRect.width;
        areaHeight = containerRect.height;

        // compute new tentative position
        let newX = posX + deltaX;
        let newY = posY + deltaY;

        // boundary constraints (shape must stay fully inside)
        // min left = 0, max left = areaWidth - shape width
        newX = Math.max(0, Math.min(newX, areaWidth - SHAPE_WIDTH));
        newY = Math.max(0, Math.min(newY, areaHeight - SHAPE_HEIGHT));

        // update state if changed
        if (newX !== posX || newY !== posY) {
          posX = newX;
          posY = newY;
          // apply to DOM
          shape.style.left = posX + 'px';
          shape.style.top = posY + 'px';
          posDisplay.textContent = `x: ${posX}, y: ${posY}`;
        }
      }

      // ----- initialize position based on initial inline styles -----
      function initPositionFromDom() {
        // read current left/top from style (set by inline)
        const leftStr = shape.style.left;   // e.g. "60px"
        const topStr = shape.style.top;
        if (leftStr) posX = parseInt(leftStr, 10) || 60;
        if (topStr) posY = parseInt(topStr, 10) || 70;
        // ensure numeric
        posX = Math.max(0, Math.min(posX, moveArea.getBoundingClientRect().width - SHAPE_WIDTH));
        posY = Math.max(0, Math.min(posY, moveArea.getBoundingClientRect().height - SHAPE_HEIGHT));
        shape.style.left = posX + 'px';
        shape.style.top = posY + 'px';
        posDisplay.textContent = `x: ${posX}, y: ${posY}`;
      }

      // call after container is ready
      setTimeout(initPositionFromDom, 10);

      // ----- GLOBAL KEYBOARD LISTENER (arrow + wasd) -----
      window.addEventListener('keydown', (event) => {
        // ignore if target is input / textarea (optional)
        const tag = event.target.tagName;
        if (tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT' || tag === 'BUTTON') {
          return;  // allow typing in controls without moving shape
        }

        const key = event.key.toLowerCase();
        let deltaX = 0, deltaY = 0;

        // arrow keys
        if (key === 'arrowup' || key === 'w') deltaY = -step;
        else if (key === 'arrowdown' || key === 's') deltaY = step;
        else if (key === 'arrowleft' || key === 'a') deltaX = -step;
        else if (key === 'arrowright' || key === 'd') deltaX = step;
        else return;  // not a movement key

        event.preventDefault();  // prevent page scrolling

        updatePosition(deltaX, deltaY);
      });

      // also add listener for wasd without arrow prefix? already covered with 'key' lowercase

      // optional: handle keyup? no need.

      // ----- toggle shape between square and circle -----
      toggleBtn.addEventListener('click', () => {
        if (shape.classList.contains('circle')) {
          shape.classList.remove('circle');
          toggleBtn.textContent = 'üîÅ to circle';
        } else {
          shape.classList.add('circle');
          toggleBtn.textContent = '‚¨ú to square';
        }
      });

      // boundary update on window resize (keep shape inside)
      window.addEventListener('resize', () => {
        // clamp current position to new container dimensions
        const containerRect = moveArea.getBoundingClientRect();
        areaWidth = containerRect.width;
        areaHeight = containerRect.height;
        // ensure posX, posY within new bounds
        posX = Math.max(0, Math.min(posX, areaWidth - SHAPE_WIDTH));
        posY = Math.max(0, Math.min(posY, areaHeight - SHAPE_HEIGHT));
        shape.style.left = posX + 'px';
        shape.style.top = posY + 'px';
        posDisplay.textContent = `x: ${posX}, y: ${posY}`;
      });

      // initial clamp after small delay (also on load)
      setTimeout(() => {
        const containerRect = moveArea.getBoundingClientRect();
        areaWidth = containerRect.width;
        areaHeight = containerRect.height;
        posX = Math.max(0, Math.min(posX, areaWidth - SHAPE_WIDTH));
        posY = Math.max(0, Math.min(posY, areaHeight - SHAPE_HEIGHT));
        shape.style.left = posX + 'px';
        shape.style.top = posY + 'px';
        posDisplay.textContent = `x: ${posX}, y: ${posY}`;
      }, 50);

      // optional: focus body to capture keys early (anyway window listener)
    })();
  </script>
</body>
</html>